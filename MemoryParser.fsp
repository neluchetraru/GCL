%{
open GCLTypesAST
%}

%token <int> NUM
%token <string> VARNAME
%token ASSGN TIMES DIV PLUS MINUS POW LPAR RPAR SRB SLB TT FF UAND UOR AND OR NOT EQ NEQ GT GTE LT LTE EOF COMMA

// Figure out associativity
%left TIMES DIV PLUS MINUS UAND UOR AND OR
%right POW NOT COMMA
%start start

// We specify the return type of each of then non-terminal symbols
%type <command> start
%type <command> C
%type <aexpr> a
%type <bexpr> b

%%
// Start node is a command
start: C EOF             { $1 }

// definition of arithmetical expression
a:
    | VARNAME                 { VAR($1) }
    | NUM                     { Num($1) }
    | MINUS a                 { UMinusExpr($2) }
    | PLUS a                  { UPlusExpr($2) }
    | VARNAME SLB a SRB     { Array($1,$3) }
    | a PLUS a                { PlusExpr($1,$3) }
    | a MINUS a               { MinusExpr($1,$3) }
    | a TIMES a               { TimesExpr($1,$3) }
    | a DIV a                 { DivExpr($1,$3) }
    | a POW a                 { PowExpr($1,$3) }
    | LPAR a RPAR             { $2 }

// boolean expression parser rules
b: 
    | TT { T }
    | FF { F }
    | b UAND b { UANDExpr($1,$3) }
    | b UOR b { UORExpr($1,$3) }
    | b AND b { ANDExpr($1,$3) }
    | b OR b { ORExpr($1,$3) }
    | NOT b { NOTExpr($2) }
    | a EQ a { EQExpr($1,$3) }
    | a NEQ a { NEQExpr($1,$3) }
    | a GT a { GTExpr($1,$3) }
    | a GTE a { GTEExpr($1,$3) }
    | a LT a { LTExpr($1,$3) }
    | a LTE a { LTEqExpr($1,$3) } 
    | LPAR b RPAR { $2 }


// command parser rules
C: 
    | C COMMA C { ComposeMem($1,$3) }
    | VARNAME ASSGN a { Assign($1,$3) }
    | VARNAME SLB a SRB ASSGN a { AssignAt($1,$3,$6) } 
    | VARNAME ASSGN SLB a SRB { AssignList($1,$4) }

%%

// 